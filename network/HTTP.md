# HTTP相关

## HTTP协议介绍

HyperText Transfer Protocol 超文本传输协议

基于TCP/IP协议的应用层协议

用于定义WEB浏览器与WEB服务器之间交换数据的过程

## 请求方法 8种 *

HTTP1.0: GET POST HEAD

HTTP1.1: + OPTIONS、PUT、DELETE、TRACE 和 CONNECT 

1、OPTIONS

返回服务器针对特定资源所支持的**HTTP请求方法**，也可以利用向web服务器发送‘*’的请求来**测试服务器的功能性**

2、**HEAD**

向服务器索与GET请求相一致的响应，只不过**响应体将不会被返回**。这一方法可以再不必传输整个响应内容的情况下，就可以**获取包含在响应小消息头中的元信息**。

3、**GET**

向特定的资源发出请求。注意：GET方法不应当被用于产生“副作用”的操作中，例如在Web Application中，其中一个原因是GET可能会被网络蜘蛛等随意访问。

4、**POST**

向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 

5、PUT

向指定资源位置上传其最新内容

6、DELETE

请求服务器删除Request-URL所标识的资源

7、TRACE

回显服务器收到的请求，主要用于测试或诊断

8、CONNECT

HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。

## HTTP各版本的差别

主要涉及：1.0 1.1 2.0

### 1.0与1.1的区别

1. http1.1默认开启keep-alive一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。

2. http1.1拥有更多的控制缓存的字段，

   1.0的时候一般使用If-Modified-Since,**Expires**来控制缓存，

   1.1提供了**Entity tag**，If-Unmodified-Since, If-Match, If-None-Match等来控制缓存。

3. 带宽优化及网络连接的使用

4. 错误通知的管理

5. Host头处理

### 1.x和2.0的区别 *

[Http2.0内容](https://zhuanlan.zhihu.com/p/89471776)

1. **多路复用**

   Http/1.1时代，浏览器客户端在同一时间，针对同一域名下的请求有一定数量的限制，超过限制数目的请求会被阻塞。2.0使用多路复用，允许**同时通过单一的http/2 连接发起多重的请求-响应消息**

2. **二进制分帧**

   将所有传输信息分割为更小的消息和帧，用二进制编码，改进传输新能

3. **header压缩**

   header带有大量信息，通讯双发各自**缓存一份头部字段表**，对于一些通信期间不会改变的通用数据（用户代理等）**避免重复传输，减少每次传输的大小**。采用HPACK算法

4. **服务端推送** [参考](https://www.ruanyifeng.com/blog/2018/03/http2_server_push.html)

   唯一一个需要开发者自己配置的功能。还**没有收到浏览器的请求，服务器就把各种资源推送给浏览器**，这样只要一轮HTTP通信，浏览器就能得到全部资源



## 状态码

### 分类

| 分类 | 分类描述                                       |
| :--- | :--------------------------------------------- |
| 1**  | 信息，服务器收到请求，需要请求者继续执行操作   |
| 2**  | 成功，操作被成功接收并处理                     |
| 3**  | 重定向，需要进一步的操作以完成请求             |
| 4**  | 客户端错误，请求包含语法错误或无法完成请求     |
| 5**  | 服务器错误，服务器在处理请求的过程中发生了错误 |

### 精简版 *

1xx -> 信息性状态码

2xx -> 请求成功

1. 200 -> 网络请求成
2. 204 -> 请求成功，但是服务没有内容返回
3. 206 -> 请求成功，服务器返回指定范围内的内容

3xx -> 重定向

1. 301 -> 永久重定向（网站域名永久更改，有利于搜索引擎优化）
2. 302 -> 临时重定向（活动页面，将首页临时重定向到活动页）
3. 303 -> 和301一样，GET、POST
4. 307 -> 和302一样，GET

4xx -> 资源问题

1. 400 -> 请求报文语法错误
2. 401 -> 需要进行授权
3. 403 -> 没有权限访问资源
4. 404 -> 没有找到对应资源

5xx -> 服务器问题

1. 500 -> 一般为后端发生错误，代码错误等
2. 502 -> Bad Gateway
3. 503 -> 服务器繁忙或者停机等情况
4. 504 -> Bad Gateway timeout

### 完整版

| 状态码  | 状态码英文名称                  | 中文描述                                                     |
| :------ | :------------------------------ | :----------------------------------------------------------- |
| 100     | Continue                        | 继续。客户端应继续其请求                                     |
| 101     | Switching Protocols             | 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议 |
| **200** | **OK**                          | **请求成功。一般用于GET与POST请求**                          |
| 201     | Created                         | 已创建。成功请求并创建了新的资源                             |
| 202     | Accepted                        | 已接受。已经接受请求，但未处理完成                           |
| 203     | Non-Authoritative Information   | 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本 |
| **204** | **No Content**                  | **无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档** |
| 205     | Reset Content                   | 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 |
| **206** | **Partial Content**             | **部分内容。服务器成功处理了部分GET请求**                    |
| 300     | Multiple Choices                | 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 |
| **301** | **Moved Permanently**           | **永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替** |
| **302** | **Found**                       | **临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI** |
| **303** | **See Other**                   | 查看其它地址。与301类似。使用**GET和POST**请求查看           |
| **304** | ==**Not Modified**==            | **未修改**。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 |
| 305     | Use Proxy                       | 使用代理。所请求的资源必须通过代理访问                       |
| 306     | Unused                          | 已经被废弃的HTTP状态码                                       |
| **307** | **Temporary Redirect**          | 临时重定向。与302类似。使用**GET**请求重定向                 |
| **400** | **Bad Request**                 | **客户端请求的语法错误，服务器无法理解**                     |
| **401** | **Unauthorized**                | **请求要求用户的身份认证**                                   |
| 402     | Payment Required                | 保留，将来使用                                               |
| **403** | **Forbidden**                   | **服务器理解请求客户端的请求，但是拒绝执行此请求**           |
| **404** | **Not Found**                   | **服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面** |
| 405     | Method Not Allowed              | 客户端请求中的方法被禁止                                     |
| 406     | Not Acceptable                  | 服务器无法根据客户端请求的内容特性完成请求                   |
| 407     | Proxy Authentication Required   | 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权 |
| 408     | Request Time-out                | 服务器等待客户端发送的请求时间过长，超时                     |
| 409     | Conflict                        | 服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突 |
| 410     | Gone                            | 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 |
| 411     | Length Required                 | 服务器无法处理客户端发送的不带Content-Length的请求信息       |
| 412     | Precondition Failed             | 客户端请求信息的先决条件错误                                 |
| 413     | Request Entity Too Large        | 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 |
| 414     | Request-URI Too Large           | 请求的URI过长（URI通常为网址），服务器无法处理               |
| 415     | Unsupported Media Type          | 服务器无法处理请求附带的媒体格式                             |
| 416     | Requested range not satisfiable | 客户端请求的范围无效                                         |
| 417     | Expectation Failed              | 服务器无法满足Expect的请求头信息                             |
| **500** | **Internal Server Error**       | **服务器内部错误，无法完成请求**                             |
| 501     | Not Implemented                 | 服务器不支持请求的功能，无法完成请求                         |
| **502** | **Bad Gateway**                 | **作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应** |
| **503** | **Service Unavailable**         | 由于**超载或系统维护**，**服务器暂时的无法处理客户端的请求**。延时的长度可包含在服务器的Retry-After头信息中 |
| **504** | **Gateway Time-out**            | **充当网关或代理的服务器，未及时从远端服务器获取请求**       |
| 505     | HTTP Version not supported      | 服务器不支持请求的HTTP协议的版本，无法完成处理               |

# TCP UDP相关

[参考](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E4%BC%A0%E8%BE%93%E5%B1%82.md#udp-%E5%92%8C-tcp-%E7%9A%84%E7%89%B9%E7%82%B9)

## TCP和UDP概念

TCP和UDP是传输层协议，提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。

- 用户数据报协议 **UDP**（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。
- 传输控制协议 **TCP**（Transmission Control Protocol）是**面向连接**的，提供**可靠交付**，有**流量控制**，**拥塞控制**，提供**全双工通信**，面向**字节流**（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是**点对点**的（一对一）。

## TCP握手

TCP报文段的一些Header格式

- **序号** seq：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。
- **确认号** ack：**期望**收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。
- **确认 ACK** ：**当 ACK=1 时确认号ack字段有效**，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。
- **同步 SYN** ：在连接建立时用来同步序号。
  - **连接请求**报文段：**SYN=1，ACK=0** 
  - **同意建立连接**，则响应报文中：**SYN=1，ACK=1**
- **终止 FIN** ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。

### 三次握手

#### 建立连接过程 *

![](https://camo.githubusercontent.com/1a8423d689b0c5bd9bcebb68114349f50a0ba5fa4a3584db580b749515b99c50/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65393264306562632d376434362d343133622d616563312d3334613339363032663738372e706e67)

假设 A 为客户端，B 为服务器端。

- 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。
- A 向 B 发送连接请求报文，**SYN=1，ACK=0**，选择一个初始的序号 x。
- B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，**SYN=1，ACK=1**，确认号为 x+1，同时也选择一个初始的序号 y。
- A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。
- B 收到 A 的确认后，连接建立。

#### **三次握手的原因**

第三次握手是为了**防止失效的连接请求到达服务器**，让服务器错误打开连接，客户端会丢弃失效的连接，但服务器会一直维持这个资源，造成浪费。

两次握手不够的原因是：两次只能让服务端接收并发送请求，缺没办法知道客户端是否将这次请求判定为成功

四次五次也可以，但是浪费

### 四次握手

#### 释放连接过程 *

![](https://camo.githubusercontent.com/790654187401ebbe3f8b7b5c25abc4e234b13a5fde546963d201e2092e964a25/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f66383761666537322d633264662d346331322d616330332d3962386435383161386166382e6a7067)

- A 发送连接释放报文，FIN=1。
- B 收到之后发出确认，此时 TCP 属于**半关闭状态**，B 能向 A 发送数据但是 A 不能向 B 发送数据。
- 当 B 不再需要连接时，发送连接释放报文，FIN=1。
- A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。
- B 收到 A 的确认后释放连接。

#### 四次握手的原因

客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了**让服务器端发送还未传送完毕的数据**，传送完毕之后，服务器会发送 FIN 连接释放报文

#### TIME_WAIT原因

客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：

- **确保最后一个确认报文能够到达**。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。
- 等待一段时间是为了**让本连接持续时间内所产生的所有报文都从网络中消失**，使得下一个新的连接不会出现旧的连接请求报文。

# 从浏览器地址栏输入url到显示页面的步骤

https://blog.csdn.net/weixin_33827731/article/details/85800486

## 浏览器发送请求

### 1. 输入URL，查看缓存

- 如果资源未缓存，发起新请求

- 如果已缓存，检验是否足够新鲜
  
  - 足够新鲜直接提供给客户端
  
  - 否则与服务器进行验证
  
    检验新鲜通常有两个HTTP头进行控制`Expires`和`Cache-Control`
    - HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期
    - HTTP1.1增加了`Cache-Control: max-age=...`,值为以秒为单位的最大新鲜时间
  

### 2. URL解析 *

获取协议，主机，端口号，path，组装HTTP请求报文

URL的一般形式：

> **<协议>://<主机>:<端口>/<路径>?<参数>**#<位置标识符>
>
> http://127.0.0.1:3000/server?a=100&b=200#print

- <协议>有http、https、ftp等
- <主机>可以是主机域名或IP地址。（域名可通过域名解析得到主机IP）
- <端口>用于标识主机的应用进程
- <路径>应用进程通过<路径>找到需要访问的资源位置
- <参数>给该进程传递参数对资源进行相应的处理
- <位置标识符>浏览器会该位置滚动到页面可视区域内，这个位置标识符不会被加入HTTP请求

### 3. 组装HTTP请求报文 *

HTTP报文格式

>请求行	GET /server/1.png HTTP/1.1
>
>请求头	key: value键值对
>
>空行
>
>请求体	GET没有携带数据

### 4. DNS解析 *

DNS域名解析获取主机IP，依次查找：[详见](https://blog.csdn.net/qq_32252957/article/details/82991880)

- 浏览器DNS缓存
- 本机DNS缓存
- hosts文件
- 路由器缓存
- ISP DNS缓存
- DNS递归查询（可能存在负载均衡导致每次IP不一样）

### 5. 建立TCP连接 *

与目标IP地址和端口号建立TCP链接，**三次握手**，连接建立后**发送HTTP请求**

## 服务器接收请求 发送响应

1. 接受请求并解析，将请求转发到服务程序
1. 服务程序检查HTTP是否包含**缓存验证信息**（浏览器第一步的验证新鲜），新鲜则返回状态码（304未修改）
2. 处理程序读取完整请求，准备HTTP响应，可能涉及数据库操作等
3. 服务器**将响应报文通过TCP请求发送给浏览器**

## 浏览器接收响应

### 1. 接收HTTP响应 *

根据情况选择关闭TCP连接 **四次握手** 或保留

### 2. 检查响应状态码

1xx 3xx 4xx 5xx

### 3. 缓存资源

存储到本地，disk cache或memory cache

分两种：[详见](https://zhuanlan.zhihu.com/p/93357692)

- **强缓存**
  - 不会向服务器发送请求，直接从缓存中读取资源，
  - 可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control
- **协商缓存**
  - 协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程
  - 可以通过设置两种 HTTP Header，Last-Modified或者ETag实现

### 4. 解码

gzip（一种压缩方式，[详见](https://segmentfault.com/a/1190000012571492)）需要服务器和浏览器都支持

### 5. 处理资源

资源可能是HTML、JS、CSS、图像等

#### 渲染HTML的过程 *

![](https://upload-images.jianshu.io/upload_images/3534846-00ef9f3d405462ef.png?imageMogr2/auto-orient/strip|imageView2/2/w/624/format/webp)

1. 将HTML文档解析成 **DOM 树**。
2. 处理 CSS 标记，构建 **CSSOM 树**。
3. 将 DOM 与 CSSOM 合并成一个**渲染树**。
4. 根据渲染树来**布局**，以计算每个节点的几何信息。
5. 将各个节点**绘制**到屏幕上。

注*解析过程中遇到图片、样式表、js文件，**启动下载**

具体渲染的原理与过程，以及优化方案详见：

https://www.jianshu.com/p/e6252dc9be32

# 浏览器内核

主要分成两部分：渲染引擎(`layout engineer`或`Rendering Engine`)和`JS`引擎

- **渲染引擎**：负责取得网页的内容（`HTML`、`XML`、图像等等）、整理讯息（例如加入`CSS`等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核
- **`JS`引擎**：解析和执行`javascript`来实现网页的动态效果
- 最开始渲染引擎和`JS`引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎

## 常见内核

- `Trident`内核：`IE,MaxThon,TT,The World,360`,搜狗浏览器等。[又称MSHTML]
- `Gecko`内核：`Netscape6`及以上版本，`FF,MozillaSuite/SeaMonkey`等
- `Presto`内核：`Opera7`及以上。 [`Opera`内核原为：Presto，现为：`Blink`;]
- `Webkit`内核：`Safari,Chrome`等。 [ `Chrome`的`Blink`（`WebKit`的分支）]

# 安全性问题

https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies

## Cookie

https://blog.csdn.net/playboyanta123/article/details/79464684

Cookie是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。

> 创建Cookie的过程：
>
> - 服务器使用 [`Set-Cookie`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie) 响应头部向用户代理（一般是浏览器）发送 Cookie信息
>
> - 该服务器发起的每一次新请求，浏览器都会将之前保存的Cookie信息通过 [`Cookie`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cookie) 请求头部再发送给服务器。

通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。

Cookie 使基于[无状态](https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview#http_is_stateless_but_not_sessionless)的HTTP协议**记录稳定的状态信息**成为了可能。

Cookie曾用于客户端数据存储，但是现在被Storage API等取代

每个域名下的cookie 的大小最大为4KB，每个域名下的`cookie`数量最多为20个（但很多浏览器厂商在具体实现时支持大于20个）

### localStorage sessionStorage *

- `cookie`是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）
- cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递
- `sessionStorage`和`localStorage`不会自动把数据发给服务器，**仅在本地保存**
- 存储大小：
  - `cookie`数据大小不能超过4k，每个域名下的`cookie`数量最多为20个
  - `sessionStorage`和`localStorage`虽然也有存储大小的限制，但比`cookie`大得多，可以达到5M或更大
- 有期时间：
  - `localStorage` **存储持久数据**，浏览器关闭后数据不丢失除非主动删除数据
  - `sessionStorage` 数据在当前**浏览器窗口关闭后自动删除**
  - `cookie` 设置的`cookie`**过期时间之前一直有效**，即使窗口或浏览器关闭

## 攻击

### XSS

https://zhuanlan.zhihu.com/p/61773197

> （Cross-Site Scripting，跨域脚本攻击）
>
> 是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。其重点是『**跨域**』和『**客户端执行**』。

**如何防御**

最普遍的做法是转义输入输出的内容，对于引号，尖括号，斜杠进行转义

### CSRF

> 跨站请求伪造（英语：`Cross-site request forgery`），也被称为 `one-click attack`或者 `session riding`，通常缩写为 `CSRF` 或者 `XSRF`， 是一种挟制用户在当前已登录的`Web`应用程序上执行非本意的操作的攻击方法

> `CSRF` 就是利用用户的登录态发起恶意请求

**如何防御**

- `Get` 请求不对数据进行修改
- 不让第三方网站访问到用户 `Cookie`
- 阻止第三方网站请求接口
- 请求时附带验证信息，比如验证码或者 `token`

# 子网掩码 计算

https://blog.csdn.net/Faker_Wang/article/details/80747407

子网掩码：必须和IP地址一起使用，用于指明一个IP哪些位标识主机所在的子网，哪些位标识主机的位掩码，即，**将IP地址划分为网络地址和主机地址**

例如：206 110 4 0/18，表示ip地址为206.110.4.0，子网掩码为18个1

子网掩码全1的部分对应网络，全0的部分对应主机

网络地址：主机地址部分全0

广播地址：主机地址部分全1

主机的数量：$2^{主机位位数}-2$

## 根据IP地址和子网掩码计算

一个主机的IP地址是202.112.14.137，掩码是255.255.255.224，要求计算这个主机所在网络的网络地址和广播地址

主机地址转成二进制：

> 11001010.01110000.00001110.10001001

掩码转成二进制：

> 11111111.11111111.11111111.111==00000==

**网络地址**：主机地址部分全0

> ==11001010.01110000.00001110.100==00000
>
> 202.112.14.128

**广播地址**：主机地址部分全1

> 11001010.01110000.00001110.100==11111==
>
> 202.112.14.159

广播地址范围：去掉广播地址和网络地址

> 202.112.14.129-202.112.14.158

**主机数**：主机号有5位，就是32个地址，但是有两个被广播和网络占用

> $2^5-2=30$

### 根据主机数量计算子网掩码

14台主机，子网掩码？

> 14（主机）+**1（网关）**+1（网络地址）+1（广播地址）=17
>
> 注意！不要忘记给网关分配一个地址

4位只有15个状态，所以需要5位，那么子网掩码为

>11111111.11111111.11111111.111==00000==
>
>255.255.255.==224==

## 根据子网数计算每一个子网掩码

206.110.4.0/18被划分成16个子网，每个子网掩码？

> 11001110.01101110.00==001000.00000000==
>
> 11111111.11111111.11000000.00000000

主机位有14位，划分成$16=2^4$个子网，，分4位划分子网，剩余10位给主机

新的子网掩码：

> 11111111.11111111.11==1111==00.00000000

