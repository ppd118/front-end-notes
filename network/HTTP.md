# HTTP相关

## HTTP协议介绍

HyperText Transfer Protocol 超文本传输协议

基于TCP/IP协议的应用层协议

用于定义WEB浏览器与WEB服务器之间交换数据的过程

## 请求方法 8种 *

HTTP1.0: GET POST HEAD

HTTP1.1: + OPTIONS、PUT、DELETE、TRACE 和 CONNECT 

1、OPTIONS

返回服务器针对特定资源所支持的**HTTP请求方法**，也可以利用向web服务器发送‘*’的请求来**测试服务器的功能性**

2、**HEAD**

向服务器索与GET请求相一致的响应，只不过**响应体将不会被返回**。这一方法可以再不必传输整个响应内容的情况下，就可以**获取包含在响应小消息头中的元信息**。

3、**GET**

向特定的资源发出请求。注意：GET方法不应当被用于产生“副作用”的操作中，例如在Web Application中，其中一个原因是GET可能会被网络蜘蛛等随意访问。

4、**POST**

向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 

5、PUT

向指定资源位置上传其最新内容，`PUT` 与 [`POST`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST) 方法的区别在于，PUT方法是幂等的：**调用一次与连续调用多次是等价的**（即没有副作用），而连续调用多次POST方法可能会有副作用，比如将一个订单重复提交多次。

- 没有资源，则创建，返回201
- 有资源

6、DELETE

请求服务器删除Request-URL所标识的资源

7、TRACE

回显服务器收到的请求，主要用于测试或诊断

8、CONNECT

HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。

### GET和POST请求的区别

Post 和 Get 是 HTTP 请求的两种方法

- **应用场景：**
  - 幂等性：指一次和多次请求某一个资源应该具有同样的副作用 [参考](https://blog.csdn.net/kepengs/article/details/82706721)
  - Get 请求是一个**幂等**的请求，一般 Get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网页的资源。
  - Post **不**是一个**幂等**的请求，一般用于对服务器资源会产生影响的情景，比如注册用户这一类的操作。
- **是否缓存：**因为两者应用场景不同，浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存。
  - Get会**缓存**
  - Post不会缓存
- **发送的报文格式：**
  - Get 请求的报文中**请求体为空**
  - Post 请求的报文中请求体一般为向服务器发送的数据。
- **安全性：**
  - 历史记录：
    - Get请求保存在浏览器历史记录，且可以将url的payload显示在地址栏
    - Post请求不会存在历史记录
  - 明文传输：
    - Get和Post本质上都是明文传输，不安全，传密码等敏感信息还是要用HTTPS
  - 黑客攻击：
    - Get请求容易产生CSRF攻击，而Post被CSRF攻击的成本更高
- **请求长度：**
  - 浏览器由于对 url 长度的限制，所以会影响 get 请求发送数据时的长度。这个限制是浏览器规定的，并不是 RFC 规定的。
- **参数类型：**
  - post 的参数传递支持更多的数据类型。

###  POST和PUT请求的区别

| 区别     | POST                         | PUT                                               |
| -------- | ---------------------------- | ------------------------------------------------- |
| 幂等     | 不幂等                       | 是**幂等**的，执行多次同样的PUT请求，结果是一样的 |
| 指定资源 | 不需指定                     | 需要指定资源对象                                  |
| 创建资源 | 自己不创建资源，服务器来创建 | 指定的资源不存在，则创建资源                      |
| 修改资源 | 对已经存在的资源新增内容     | 整个替换指定的资源为新的值                        |

- PUT请求是向服务器端发送数据，从而修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次PUT操作，其结果并没有不同。（可以理解为时**更新数据**）
- POST请求是向服务器端发送数据，该请求会改变数据的种类等资源，它会创建新的内容。（可以理解为是**创建数据**）

## HTTP各版本的差别

主要涉及：1.0 1.1 2.0

### 1.0与1.1的区别

1. http1.1默认开启keep-alive一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。

2. http1.1拥有更多的控制缓存的字段，

   1.0的时候一般使用If-Modified-Since,**Expires**来控制缓存，

   1.1提供了**Entity tag**，If-Unmodified-Since, If-Match, If-None-Match等来控制缓存。

3. 带宽优化及网络连接的使用

4. 错误通知的管理

5. Host头处理

### 1.x和2.0的区别 *

[Http2.0内容](https://zhuanlan.zhihu.com/p/89471776)

1. **多路复用**

   Http/1.1时代，浏览器客户端在同一时间，针对同一域名下的请求有一定数量的限制，超过限制数目的请求会被阻塞。2.0使用多路复用，允许**同时通过单一的http/2 连接发起多重的请求-响应消息**

2. **二进制分帧**

   将所有传输信息分割为更小的消息和帧，用二进制编码，改进传输新能

3. **header压缩**

   header带有大量信息，通讯双发各自**缓存一份头部字段表**，对于一些通信期间不会改变的通用数据（用户代理等）**避免重复传输，减少每次传输的大小**。采用HPACK算法

4. **服务端推送** [参考](https://www.ruanyifeng.com/blog/2018/03/http2_server_push.html)

   唯一一个需要开发者自己配置的功能。还**没有收到浏览器的请求，服务器就把各种资源推送给浏览器**，这样只要一轮HTTP通信，浏览器就能得到全部资源

## 状态码

### 分类

| 分类 | 分类描述                                       |
| :--- | :--------------------------------------------- |
| 1**  | 信息，服务器收到请求，需要请求者继续执行操作   |
| 2**  | 成功，操作被成功接收并处理                     |
| 3**  | 重定向，需要进一步的操作以完成请求             |
| 4**  | 客户端错误，请求包含语法错误或无法完成请求     |
| 5**  | 服务器错误，服务器在处理请求的过程中发生了错误 |

### 精简版 *

1xx -> 信息性状态码

2xx -> 请求成功

1. **200** -> 网络请求成
2. 204 -> 请求成功，但是服务没有内容返回
3. 206 -> 请求成功，服务器返回指定范围内的内容

3xx -> 重定向

1. **301** -> 永久重定向（网站域名永久更改，有利于搜索引擎优化）
2. **302** -> 临时重定向（活动页面，将首页临时重定向到活动页）
3. 303 -> 和301一样，GET、POST
3. **304** -> 资源未修改，用于缓存
4. 307 -> 和302一样，GET

4xx -> 资源问题

1. 400 -> 请求报文语法错误
2. 401 -> 需要进行授权
3. 403 -> 没有权限访问资源
4. **404** -> 没有找到对应资源

5xx -> 服务器问题

1. 500 -> 一般为后端发生错误，代码错误等
2. 502 -> Bad Gateway 网关或代理服务器收到**无效响应**
3. **503** -> 服务器**繁忙或者停机维护**等情况
4. **504** -> Bad Gateway timeout，网关或代理服务器收到**超时**未获取响应

### 完整版

| 状态码  | 状态码英文名称                  | 中文描述                                                     |
| :------ | :------------------------------ | :----------------------------------------------------------- |
| 100     | Continue                        | 继续。客户端应继续其请求                                     |
| 101     | Switching Protocols             | 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议 |
| **200** | **OK**                          | **请求成功。一般用于GET与POST请求**                          |
| 201     | Created                         | 已创建。成功请求并创建了新的资源                             |
| 202     | Accepted                        | 已接受。已经接受请求，但未处理完成                           |
| 203     | Non-Authoritative Information   | 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本 |
| **204** | **No Content**                  | **无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档** |
| 205     | Reset Content                   | 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 |
| **206** | **Partial Content**             | **部分内容。服务器成功处理了部分GET请求**                    |
| 300     | Multiple Choices                | 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 |
| **301** | **Moved Permanently**           | **永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替** |
| **302** | **Found**                       | **临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI** |
| **303** | **See Other**                   | 查看其它地址。与302类似。使用**GET和POST**请求查看           |
| **304** | ==**Not Modified**==            | **未修改**。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 |
| 305     | Use Proxy                       | 使用代理。所请求的资源必须通过代理访问                       |
| 306     | Unused                          | 已经被废弃的HTTP状态码                                       |
| **307** | **Temporary Redirect**          | 临时重定向。与302类似。只能使用**GET**请求重定向             |
| **400** | **Bad Request**                 | **客户端请求的语法错误，服务器无法理解**                     |
| **401** | **Unauthorized**                | **请求要求用户的身份认证**                                   |
| 402     | Payment Required                | 保留，将来使用                                               |
| **403** | **Forbidden**                   | **服务器理解请求客户端的请求，但是拒绝执行此请求**           |
| **404** | **Not Found**                   | **服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面** |
| 405     | Method Not Allowed              | 客户端请求中的方法被禁止                                     |
| 406     | Not Acceptable                  | 服务器无法根据客户端请求的内容特性完成请求                   |
| 407     | Proxy Authentication Required   | 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权 |
| 408     | Request Time-out                | 服务器等待客户端发送的请求时间过长，超时                     |
| 409     | Conflict                        | 服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突 |
| 410     | Gone                            | 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 |
| 411     | Length Required                 | 服务器无法处理客户端发送的不带Content-Length的请求信息       |
| 412     | Precondition Failed             | 客户端请求信息的先决条件错误                                 |
| 413     | Request Entity Too Large        | 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 |
| 414     | Request-URI Too Large           | 请求的URI过长（URI通常为网址），服务器无法处理               |
| 415     | Unsupported Media Type          | 服务器无法处理请求附带的媒体格式                             |
| 416     | Requested range not satisfiable | 客户端请求的范围无效                                         |
| 417     | Expectation Failed              | 服务器无法满足Expect的请求头信息                             |
| **500** | **Internal Server Error**       | **服务器内部错误，无法完成请求**                             |
| 501     | Not Implemented                 | 服务器不支持请求的功能，无法完成请求                         |
| **502** | **Bad Gateway**                 | **作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应** |
| **503** | **Service Unavailable**         | 由于**超载或系统维护**，**服务器暂时的无法处理客户端的请求**。延时的长度可包含在服务器的Retry-After头信息中 |
| **504** | **Gateway Time-out**            | **充当网关或代理的服务器，未及时从远端服务器获取请求**       |
| 505     | HTTP Version not supported      | 服务器不支持请求的HTTP协议的版本，无法完成处理               |

# TCP UDP相关

[参考](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E4%BC%A0%E8%BE%93%E5%B1%82.md#udp-%E5%92%8C-tcp-%E7%9A%84%E7%89%B9%E7%82%B9)

## TCP和UDP概念

TCP和UDP是传输层协议，提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。

- 用户数据报协议 **UDP**（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。
- 传输控制协议 **TCP**（Transmission Control Protocol）是**面向连接**的，提供**可靠交付**，有**流量控制**，**拥塞控制**，提供**全双工通信**，面向**字节流**（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是**点对点**的（一对一）。

## TCP握手

TCP报文段的一些Header格式

- **序号** seq：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。
- **确认号** ack：**期望**收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。
- **确认 ACK** ：**当 ACK=1 时确认号ack字段有效**，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。
- **同步 SYN** ：在连接建立时用来同步序号。
  - **连接请求**报文段：**SYN=1，ACK=0** 
  - **同意建立连接**，则响应报文中：**SYN=1，ACK=1**
- **终止 FIN** ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。

### 三次握手

#### 建立连接过程 *

![image-20220413195201878](.\img\HTTP\image-20220413195201878.png)

假设 A 为客户端，B 为服务器端。

- 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。
- A 向 B 发送连接请求报文，**SYN=1，ACK=0**，选择一个初始的序号 x。
- B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，**SYN=1，ACK=1**，确认号为 x+1，同时也选择一个初始的序号 y。
- A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。
- B 收到 A 的确认后，连接建立。

#### **三次握手的原因**

第三次握手是为了**防止失效的连接请求到达服务器**，让服务器错误打开连接，客户端会丢弃失效的连接，但服务器会一直维持这个资源，造成浪费。

两次握手不够的原因是：两次只能让服务端接收并发送请求，缺没办法知道客户端是否将这次请求判定为成功

四次五次也可以，但是浪费

### 四次握手

#### 释放连接过程 *

![image-20220413195236682](.\img\HTTP\image-20220413195236682.png)

- A 发送连接释放报文，FIN=1。
- B 收到之后发出确认，此时 TCP 属于**半关闭状态**，B 能向 A 发送数据但是 A 不能向 B 发送数据。
- 当 B 不再需要连接时，发送连接释放报文，FIN=1。
- A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。
- B 收到 A 的确认后释放连接。

#### 四次握手的原因

客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了**让服务器端发送还未传送完毕的数据**，传送完毕之后，服务器会发送 FIN 连接释放报文

#### TIME_WAIT原因

客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：

- **确保最后一个确认报文能够到达**。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。
- 等待一段时间是为了**让本连接持续时间内所产生的所有报文都从网络中消失**，使得下一个新的连接不会出现旧的连接请求报文。

## HTTP缓存

https://www.jianshu.com/p/227cee9c8d15

![](https://upload-images.jianshu.io/upload_images/4845448-ab0e961921da5694?imageMogr2/auto-orient/strip|imageView2/2/w/690/format/webp)

分两种：[详见](https://zhuanlan.zhihu.com/p/93357692)

### 强缓存

- 缓存数据**未失效**的情况下，那么就会直接使用浏览器的缓存数据，不会再向服务器发送任何请求。
- 可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control
- 判断过期：
  - HTTP1.0：Expires的缓存时间没有过期
  - HTTP1.1：Cache-Control的max-age没有过期
- 强制缓存生效时，http状态码为200，chrome中缓存从两种地方获取：
  - from memory cache (从内存中获取/一般缓存更新频率较高的js、图片、字体等资源)
  - from disk cache (从磁盘中获取/一般缓存更新频率较低的js、css等资源)

#### Expires

HTTP1.0的强缓存，值为过期时间（秒级），现在基本不用，优先考虑Cache-Control

**缺点**：存储的是服务器的时间，无法应对客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况

#### Cache-Control 

HTTP1.1的强缓存，置为有效时间（秒级）

- 例如，max-age=300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。

属性：

- `public`：设置了该字段值的资源表示可以被任何对象（包括：发送请求的客户端、代理服务器等等）缓存。这个字段值不常用，一般还是使用max-age=来精确控制；
- `private`：设置了该字段值的资源**只能被用户浏览器缓存**，不允许任何代理服务器缓存。在实际开发当中，对于一些含有用户信息的HTML，通常都要设置这个字段值，避免代理服务器(CDN)缓存；

- **`no-cache`**：客户端缓存内容，是否使用缓存则需要**经过协商缓存**来验证决定。
  - 表示不使用 Cache-Control的缓存控制方式做前置验证，而是使用 Etag 或者Last-Modified字段来控制缓存。

- **`no-store`**：所有内容都不会被缓存，即**不使用强制缓存，也不使用协商缓存**(memory cache也会失效)

- **`max-age`**：max-age=xxx 表示缓存内容将在xxx秒后失效

当两种强缓存方式一起使用时，Cache-Control 的优先级要高于 Expires

### 协商缓存

- 协商缓存就是强缓存**失效**后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程
- 可以通过设置两种 HTTP Header，Last-Modified或者ETag实现
- 判断过期：当浏览器第一次向服务器发送请求时，会在响应头中返回协商缓存的头属性：ETag和Last-Modified
  - HTTP 1.0：Last-Modified/If-Modified-Since
    - Last-Modified返回的是GMT格式的最后修改时间（只能判断秒级修改）
    - 浏览器在第二次发送请求的时候，会在请求头中带上与Last-Modified对应的If-Modified-Since，值为最后修改时间
  - HTTP 1.1：ETag/If-Not-Match 
    - ETag返回的是一个hash值
    - 浏览器在第二次发送请求的时候，会在请求头中带上与ETag对应的If-Not-Match，值为Etag的hash值
- 如果服务器资源未修改，返回304，如果有修改，返回200和新资源

#### Last-Modified

Last-Modified/ If-Modified-Since

HTTP1.0的协商缓存，值为资源文件最后一次更改时间（秒级）

缓存过程：

- 浏览器第一次请求资源
  - 服务器通过在响应头中添加 Last-Modified 属性来指出资源最后一次修改的时间，
- 浏览器下一次发起请求时
  - 浏览器在会在请求头中添加一个 If-Modified-Since 的属性，属性值为上一次资源返回时的 Last-Modified 的值。
  - 服务器会通过这个属性来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做了修改。
    - 如果资源没有修改，那么返回 304 状态，让客户端使用本地的缓存。
    - 如果资源已经被修改了，则返回200状态和修改后的资源。

**缺点**：

- 因为是秒级，如果某些文件在1秒钟以内，被修改多次的话，那么文件已将改变了但是 Last-Modified 却没有改变，这样会造成缓存命中的不准确
- 可能资源被修改过，但是值未发生变化，这种时候也不算已修改

#### Etag

Etag/ If-None-Match

全程Entity Tag，值是资源生成的唯一标识符，对输入敏感，资源发生改变后ETag也改变，可以解决Last-Modified问题

- 生成Etag的方法有很多，通常是使用内容的散列、最后修改时间戳的哈希值或简单地使用版本号

缓存过程：和Last-Modified类似

- 浏览器第一次请求资源
  - 服务器在返回资源的时候，在头信息中添加了 Etag 属性
- 浏览器下一次发起请求时
  - 浏览器会在请求头中添加一个 If-None-Match 属性，这个属性的值就是上次返回的资源的 Etag 的值。
  - 服务接收到请求后会根据这个值来和资源当前的 Etag 的值来进行比较，以此来判断资源是否发生改变，是否需要返回资源。


# 从浏览器地址栏输入url到显示页面的步骤

https://blog.csdn.net/weixin_33827731/article/details/85800486

## 浏览器发送请求

### 1. 输入URL，查看缓存

- 如果资源未缓存，发起新请求

- 如果已缓存，检验是否足够新鲜
  
  - 足够新鲜直接提供给客户端
  
  - 否则与服务器进行验证
  
    检验新鲜通常有两个HTTP头进行控制`Expires`和`Cache-Control`
    - HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期
    - HTTP1.1增加了`Cache-Control: max-age=...`,值为以秒为单位的最大新鲜时间
  

### 2. URL解析 *

获取协议，主机，端口号，path，组装HTTP请求报文

URL的一般形式：

> **<协议>://<主机>:<端口>/<路径>?<参数>**#<位置标识符>
>
> http://127.0.0.1:3000/server?a=100&b=200#print

- <协议>有http、https、ftp等
- <主机>可以是主机域名或IP地址。（域名可通过域名解析得到主机IP）
- <端口>用于标识主机的应用进程
- <路径>应用进程通过<路径>找到需要访问的资源位置
- <参数>给该进程传递参数对资源进行相应的处理
- <位置标识符>浏览器会该位置滚动到页面可视区域内，这个位置标识符不会被加入HTTP请求

### 3. 组装HTTP请求报文 *

HTTP报文格式

>请求行	GET /server/1.png HTTP/1.1
>
>请求头	key: value键值对
>
>空行
>
>请求体	GET没有携带数据

### 4. DNS解析 *

DNS域名解析获取主机IP，依次查找：[详见](https://blog.csdn.net/qq_32252957/article/details/82991880)

- 浏览器DNS缓存
- 本机DNS缓存
- hosts文件
- 路由器缓存
- ISP DNS缓存
- DNS递归查询（可能存在负载均衡导致每次IP不一样）

### 5. 建立TCP连接 *

与目标IP地址和端口号建立TCP链接，**三次握手**，连接建立后**发送HTTP请求**

## 服务器接收请求 发送响应

1. 接受请求并解析，将请求转发到服务程序
1. 服务程序检查HTTP是否包含**缓存验证信息**（浏览器第一步的验证新鲜），新鲜则返回状态码（304未修改）
2. 处理程序读取完整请求，准备HTTP响应，可能涉及数据库操作等
3. 服务器**将响应报文通过TCP请求发送给浏览器**

## 浏览器接收响应

### 1. 接收HTTP响应 *

根据情况选择关闭TCP连接 **四次握手** 或保留

### 2. 检查响应状态码

1xx 3xx 4xx 5xx

### 3. 缓存资源

如果资源可缓存，**进行缓存**

### 4. 解码

gzip（一种压缩方式，[详见](https://segmentfault.com/a/1190000012571492)）需要服务器和浏览器都支持

### 5. 处理资源

资源可能是HTML、JS、CSS、图像等

#### 渲染HTML的过程 *

![](https://upload-images.jianshu.io/upload_images/3534846-00ef9f3d405462ef.png?imageMogr2/auto-orient/strip|imageView2/2/w/624/format/webp)

1. 将HTML文档解析成 **DOM 树**。
2. 处理 CSS 标记，构建 **CSSOM 树**。
3. 将 DOM 与 CSSOM 合并成一个**渲染树**。
4. 根据渲染树来**布局**，以计算每个节点的几何信息。
5. 将各个节点**绘制**到屏幕上。

注*解析过程中遇到图片、样式表、js文件，**启动下载**

具体渲染的原理与过程，以及优化方案详见：

https://www.jianshu.com/p/e6252dc9be32

# 浏览器内核

主要分成两部分：渲染引擎(`layout engineer`或`Rendering Engine`)和`JS`引擎

- **渲染引擎**：负责取得网页的内容（`HTML`、`XML`、图像等等）、整理讯息（例如加入`CSS`等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核
- **`JS`引擎**：解析和执行`javascript`来实现网页的动态效果
- 最开始渲染引擎和`JS`引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎

## 常见内核

- `Trident`内核：`IE,MaxThon,TT,The World,360`,搜狗浏览器等。[又称MSHTML]
- `Gecko`内核：`Netscape6`及以上版本，`FF,MozillaSuite/SeaMonkey`等
- `Presto`内核：`Opera7`及以上。 [`Opera`内核原为：Presto，现为：`Blink`;]
- `Webkit`内核：`Safari,Chrome`等。 [ `Chrome`的`Blink`（`WebKit`的分支）]

# 安全性问题

https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies

## Cookie

https://blog.csdn.net/playboyanta123/article/details/79464684

Cookie是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。

> 创建Cookie的过程：
>
> - 服务器使用 [`Set-Cookie`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie) 响应头部向用户代理（一般是浏览器）发送 Cookie信息
>
> - 该服务器发起的每一次新请求，浏览器都会将之前保存的Cookie信息通过 [`Cookie`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cookie) 请求头部再发送给服务器。

通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。

Cookie 使基于[无状态](https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview#http_is_stateless_but_not_sessionless)的HTTP协议**记录稳定的状态信息**成为了可能。

Cookie曾用于客户端数据存储，但是现在被Storage API等取代

每个域名下的cookie 的大小最大为4KB，每个域名下的`cookie`数量最多为20个（但很多浏览器厂商在具体实现时支持大于20个）

### localStorage sessionStorage *

- `cookie`是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）
- cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递
- `sessionStorage`和`localStorage`不会自动把数据发给服务器，**仅在本地保存**
- 存储大小：
  - `cookie`数据大小不能超过4k，每个域名下的`cookie`数量最多为20个
  - `sessionStorage`和`localStorage`虽然也有存储大小的限制，但比`cookie`大得多，可以达到5M或更大
- 有期时间：
  - `localStorage` **存储持久数据**，浏览器关闭后数据不丢失除非主动删除数据
  - `sessionStorage` 数据在当前**浏览器窗口关闭后自动删除**
  - `cookie` 设置的`cookie`**过期时间之前一直有效**，即使窗口或浏览器关闭

## 攻击

### XSS

https://zhuanlan.zhihu.com/p/61773197

Cross-Site Scripting，跨域脚本攻击

针对**用户、客户端**的攻击

恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页面时，嵌入Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全

**如何防御**

最普遍的做法是转义输入输出的内容，对于引号，尖括号，斜杠进行转义

### CSRF

https://www.jianshu.com/p/7f33f9c7997b

Cross-site request forgery，跨站请求伪造

针对**网站，服务器**的攻击

是一种挟制用户在当前已登录的`Web`应用程序上执行非本意的操作的攻击方法，攻击者盗用了你的身份，以你的名义发送恶意请求。

`CSRF` 通过**伪装来自受信任用户**的请求来利用受信任的网站

危害：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账......造成的问题包括：个人隐私泄露以及财产安全。

**如何防御**

- `Get` 请求不对数据进行修改
- 不让第三方网站访问到用户 `Cookie`
- 阻止第三方网站请求接口
- 请求时附带验证信息，比如验证码或者 `token`

# 子网掩码 计算

https://blog.csdn.net/Faker_Wang/article/details/80747407

子网掩码：必须和IP地址一起使用，用于指明一个IP哪些位标识主机所在的子网，哪些位标识主机的位掩码，即，**将IP地址划分为网络地址和主机地址**

例如：206 110 4 0/18，表示ip地址为206.110.4.0，子网掩码为18个1

子网掩码全1的部分对应网络，全0的部分对应主机

网络地址：主机地址部分全0

广播地址：主机地址部分全1

主机的数量：$2^{主机位位数}-2$

## 根据IP地址和子网掩码计算

一个主机的IP地址是202.112.14.137，掩码是255.255.255.224，要求计算这个主机所在网络的网络地址和广播地址

主机地址转成二进制：

> 11001010.01110000.00001110.10001001

掩码转成二进制：

> 11111111.11111111.11111111.111==00000==

**网络地址**：主机地址部分全0

> ==11001010.01110000.00001110.100==00000
>
> 202.112.14.128

**广播地址**：主机地址部分全1

> 11001010.01110000.00001110.100==11111==
>
> 202.112.14.159

广播地址范围：去掉广播地址和网络地址

> 202.112.14.129-202.112.14.158

**主机数**：主机号有5位，就是32个地址，但是有两个被广播和网络占用

> $2^5-2=30$

### 根据主机数量计算子网掩码

14台主机，子网掩码？

> 14（主机）+**1（网关）**+1（网络地址）+1（广播地址）=17
>
> 注意！不要忘记给网关分配一个地址

4位只有15个状态，所以需要5位，那么子网掩码为

>11111111.11111111.11111111.111==00000==
>
>255.255.255.==224==

## 根据子网数计算每一个子网掩码

206.110.4.0/18被划分成16个子网，每个子网掩码？

> 11001110.01101110.00==001000.00000000==
>
> 11111111.11111111.11000000.00000000

主机位有14位，划分成$16=2^4$个子网，，分4位划分子网，剩余10位给主机

新的子网掩码：

> 11111111.11111111.11==1111==00.00000000

